/*
 * CurveTracer.
 * Written by Bryce Summers.
 *
 * Contains the specification of the calculus for Silhouette curves.
 */

#include "curveTracer.h"

namespace CMU462
{


  void Curve_Silhouette::find_unique_silhouette_points(int num_critical_points,
					  std::vector<PointCurve> & edges,
			  std::vector<Critical_Point> & silhouette_points)
  {
    // Now use Union find on the list of curves to derive one unique
    // origination point for every level set curve that we are interested in.
    UF_Serial UF(num_critical_points);

    // Union all edges that do not contain an origination point.
    // This decomposes the MS complex into connected components fully above the level set
    // and those that are completely below the level set.
    // The level set is the set of points satisfying the implicit equation of the final curves that we wish to extract.
    for(auto iter = edges.begin(); iter != edges.end(); ++iter)
    {
      if(iter -> has_crossing_point == false)
      {
	Critical_point & cp1 = iter -> p1;
	Critical_point & cp2 = iter -> p2;

	// Union these critical point sets.
	// The entire set will be above or below the level set.
	UF.op_union(cp1.index, cp2.index);
      }
    }

    // FIXME : If we want we could store those sets with crossing points, then
    // simply iterate over them and perhaps store a count of how many distinct
    // connected components remain and stop once there is only 1.
    
    // For all MS edges,
    // Add an origination point if the edge's two sets are not yet connected.
    for(auto iter = edges.begin(); iter != edges.end(); ++iter)
    {
      if(iter -> has_crossing_point == true)
      {
	Critical_point & cp1 = iter -> p1;
	Critical_point & cp2 = iter -> p2;

	if(!UF.connected(cp1.index, cp2.index))
	{
	  // Push
	  cp_all.push_back(iter-> level_set_crossing_point);

	  // Union these critical point sets.
	  UF.op_union(cp1.index, cp2.index);
	}
      }
    }
    
    return;
  }

  void Curve_Silhouette::morse_smale_complex(HalfedgeMesh& mesh,
			   std::vector<Critical_Point> & cp_all, // This goes out.
			   std::vector<PointCurve> & edges
					     )
  {
    // To build the MS complex, we will trace 4 gradient curves from
    // each saddle point to two min's and max's each.
    std::vector<Critical_Point> saddle_points;

    // Find all of the critical points,
    // populate the saddle point array.
    // populate the output critical points array for whomever out there might want them, for instance for visualization purposes.
    findCriticalPoints(mesh, &saddle_points, &cp_all);


    // There will be 4*|saddle_points| edges in the MS complex, because every saddle point extends 4 edges.
    
    // We will trace 4 curves for each saddle point.
    // Therefore we tell the edges vector how much space we will need.
    edges.reserve(saddle_points.size()*4);
    
    // For every saddle point, we will trace 4 gradient curves, which are MS complex edges.
    for(auto iter = saddle_points.begin(); iter != saddle_points.end(); ++iter)
    {
      Critical_Point & saddle = *iter;
      double amount = CURVE_TRACING_STEP; // FIXME, choose a more appropiate value.
      
      // ASSUMPTION: if we choose 2 perpendicular directions, then they will go in opposite gradient directions.
      // Here we are tracing gradients in 4 directions out from the saddle point.
      for(int sx = -1; sx <= 1; sx += 2)
      for(int sy = -1; sy <= 1; sy += 2)
      {
	// These act as edges in the MS Complex.
	edges.push_back(PointCurve());

	// Create a reference to the allocated curve object.
	PointCurve & curve = edges[edges.size() - 1];
 	trace_gradient(saddle, amount*sx, amount*sy, curve);
      }
    }

    return;
  }

  bool Curve_Silhouette::trace_gradient(Critical_Point cp,    // Starting point.
					double du, double dv, // Direction.
					PointCurve & curve,   // OUT: Output point curve that is populated.
					)
  {
    // Compute the a scalar 'dir' that represents whether we wish to go up or down.
    // The gradient will be multiplied by -1 if we wish to head towards a minnimum.
    Vector2D grad = grad_f(cp.u + du, cp.v + dv);
    double   dot  = grad.x*du + grad.y*dv; // Positive dot product then <du,dv>
    double   dir  = dot > 0 ? 1.0 : -1.0;  // heads uphill.   

    // The curve starts at the original given critical point.
    curve.cp1 = cp;
    curve.addPoint(cp.location);

    // Now follow the gradient until we find a max/min.
    // Add these points to the curves as we go along.
    // We transition from one bicubic patch to another
    // when we go out of [0,1] x [0,1] bounds.
    FaceIter current_face = cp.face;
    double u = cp.u;
    double v = cp.v;
    
    while()
    {

    }
    
    // Start going in the given direction and use the gradient in that direction to
    // determine whether we are going up to a maxima or down to a minima.
    
  }

  // Populates the given list with critical points found on the silhouette curve
  // function defined on the given mesh.
  void Curve_Silhouette::findCriticalPoints (HalfedgeMesh& mesh,
					     std::vector<Critical_Point> * saddle_points,
					     std::vector<Critical_Point> * all_points)
  {
    int index = 0;
    
    PatchDrawer patcher;
    for(FaceIter f = mesh.facesBegin(); f != mesh.facesEnd(); f++)
    {
      std::vector<Vector3D> control_points;
      patcher.computeControlPoints(f, control_points);
    
      Critical_Point cp;

      // FIXME : Our strategy for finding points still needs some thought.
      // IDEA1 : Perhaps critical points can only occur when curvature is present
      // in the control mesh.
      // IDEA2: Maybe search during subdivison.
      // IDEAL : analytically find the answer.
      // Maybe solve 1D problems and then trace along those routes.

      // Right now we just start at each corner of the patch and see if they find a
      // critical point inside of the patch.
      for(int u = 0; u <= 1; u++)
      for(int v = 0; v <= 1; v++)
      {
	// Find Critical Points..
	if(search_for_critical_point(control_points, u, v, cp))
	{
	  cp.type = classify_point(control_points, u, v);
	  cp.face = f;// The cp needs to know its face for direct access
	              // to the HalfEdge Mesh connectivity structure.
	  cp.index = index; // Every cp gets a unique index.
	  index++;
	  cp.f_val = F(control_points, u, v); // Store the function evaluation at this point.	  
	  
	  // Keep special track of saddle points,
	  // because we will use them in the building of a morse smale complex.
	  if(saddle_points != NULL && cp.type == SADDLE)
	  {
	    saddle_points -> push_back(cp);
	  }
	  
	  // Record all points in the larger output array.
	  if(all_point != NULL)
	  {
	    all_points -> push_back(cp);
	  }

	  // Tell the face what its critical point is.
	  f -> critical_point     = cp;
	  f -> has_critical_point = true;

	  // FIXME : We are currently only looking for one critical point per patch.
	  // This may not be an assumption that holds water.
	  break;
	}

	// Mark this face as not having a valid critical point thus far.
	f -> has_critical_point = false;
      }      
    }
  }
  
  // Follow the gradient of down to a critical point.
  // returns true if a critical point was found in [0,1] x [0,1],
  // otherwise returns false if the tracing goes out of bounds.
  bool Curve_Silhouette::search_for_critical_point(
			      std::vector<Vector3D> & control_points,
			      double u, double v,
			      Critical_Point & p)
  {
    Vector2D grad;
    do
    {
      grad = 10000*grad_f_sqr(control_points, u, v);

      u -= grad.x;
      v -= grad.y;

      if(u < 0 || u > 1 || v < 0 || v > 1)
      {
	return false;
      }
    }while(abs(grad.x) > TOLERANCE || abs(grad.y) > TOLERANCE);

    // Populate the found critical point.
    p.u = u;
    p.v = v;
    p.location = P(control_points, u, v);

    return true;
  }

  Critical_Point_Type Curve_Silhouette::classify_point(
		      std::vector<Vector3D> & control_points,
		      double u, double v)
  {
    // Compute entires in the 2 by 2 symmetric hessian matrix.
    double A = F_uu(control_points, u, v);
    double B = F_uv(control_points, u, v);
    double D = F_vv(control_points, u, v);

    // Compute the coefficients of the characteristic quadratic
    // formula Q for the hessian matrix.
    double a = 1, b = -(A + D), c = A*D - B*B;

    // Compute the Discriminant of Q.
    double disc = sqrt(b*b - 4*a*c);
    double two_a = 2*a;
        
    // Compute the eigenvalues, which are the roots of Q.
    // Using the quaratic formula.
    double val_1 = (-b + disc)/two_a;
    double val_2 = (-b - disc)/two_a;
    
    // First principle minors, correctly characterize positive definitness,
    // but not others.
    /*
    double pm_1 = A;
    double pm_2 = A*D - B*B;
    */

    //    cout << "Eigen Values: " << val_1 << ", " << val_2 << endl;
    
    /*
    if(abs(dot(N(control_points, u, v).unit(), E)) < .9)
    {
	return SADDLE;1
    }
    */

    if(abs(val_1) < TOLERANCE || abs(val_2) < TOLERANCE)
    {
      return SADDLE;
    }
    
    if(val_1 > 0 && val_2 > 0)
    {
      return MIN;
    }

    if(val_1 < 0 && val_2 < 0)
    {
      return MAX;
    }

    return SADDLE;
  };
    
  // position on surface.
  Vector3D Curve_Silhouette::P(std::vector<Vector3D> & control_points,
			       double u, double v, int partial_u, int partial_v)
  {
    /*
	Vector3D sum(0,0,0);

	for(int i = 0; i < 4; i++)
	for(int j = 0; j < 4; j++)
	{
	  sum += control_points[i + 4*j] * Bernstein(u, i) * Bernstein(v, j);
	}

	return sum;
    */
    // Evaluates a (u,v)th order partial derivative of the patch position.
    return evaluatePatch(control_points, u, v, partial_u, partial_v);
  }

  // Normal vector to surface at point P(u,v);
  Vector3D Curve_Silhouette::N(std::vector<Vector3D> & control_points,
			       double u, double v)
  {
    return cross(P(control_points, u, v, 1, 0), // P_u
		 P(control_points, u, v, 0, 1));// P_v
  }

  // F = N dot E, this defines the silhouette when it equals 0.
  double Curve_Silhouette::F(std::vector<Vector3D> & control_points,
			     double u, double v)
  {
    return dot(N(control_points, u, v), E);
  }

  // -- 1st order partial derivatives.
  double Curve_Silhouette::F_u(std::vector<Vector3D> & control_points,
			       double u, double v)
  {
    return dot(E, cross(P(control_points, u, v, 2, 0),
			P(control_points, u, v, 0, 1)) +
	          cross(P(control_points, u, v, 1, 0),
			P(control_points, u, v, 1, 1)));
  }
  
  double Curve_Silhouette::F_v(std::vector<Vector3D> & control_points,
			       double u, double v)
  {
    return dot(E, cross(P(control_points, u, v, 1, 1),
			P(control_points, u, v, 0, 1)) +
	          cross(P(control_points, u, v, 1, 0),
			P(control_points, u, v, 0, 2)));
  }

  // -- 2nd order partial derivatives.
  double Curve_Silhouette::F_uu(std::vector<Vector3D> & control_points,
				double u, double v)
  {
    return dot(E, cross(P(control_points, u, v, 3, 0),
			P(control_points, u, v, 0, 1)) +
	       
	        2*cross(P(control_points, u, v, 2, 0),
			P(control_points, u, v, 1, 1)) +

	          cross(P(control_points, u, v, 1, 0),
			P(control_points, u, v, 2, 1))
	       );
  }    
  
  // Note: F_uv = F_vu, because of 2nd partial calculus.
  double Curve_Silhouette::F_uv(std::vector<Vector3D> & control_points,
				double u, double v)
  {
    return dot(E, cross(P(control_points, u, v, 2, 1),
			P(control_points, u, v, 0, 1)) +
	       
	          cross(P(control_points, u, v, 2, 0),
			P(control_points, u, v, 0, 2)) +

	          cross(P(control_points, u, v, 1, 0),
			P(control_points, u, v, 1, 2))
	       );
  }
  
  double Curve_Silhouette::F_vv(std::vector<Vector3D> & control_points,
				double u, double v)
  {
    return dot(E, cross(P(control_points, u, v, 1, 2),
			P(control_points, u, v, 0, 1)) +
	       
	        2*cross(P(control_points, u, v, 1, 1),
			P(control_points, u, v, 0, 2)) +

	        2*cross(P(control_points, u, v, 1, 0),
			P(control_points, u, v, 0, 3))
	       );
  }


  // Returns the gradient of f at the given uv coordinates.
  Vector2D Curve_Silhouette::grad_f(std::vector<Vector3D> & control_points,
				    double u, double v)
  {
    return Vector2D(
		    F_u(control_points, u, v),
		    F_v(control_points, u, v)
		   );
  }

  // The gradient of the magnitude of the gradient of f.
  Vector2D Curve_Silhouette::grad_f_sqr(std::vector<Vector3D> & control_points,
			     double u, double v)
  {
    double f_u  = F_u(control_points, u, v);
    double f_v  = F_v(control_points, u, v);
    double f_uu = F_uu(control_points, u, v);
    double f_uv = F_uv(control_points, u, v);
    double f_vv = F_vv(control_points, u, v);

    // <
    // d/du (f_u^2 + f_v^2),
    // d/dv ...
    // >
    
    return Vector2D(
		    2*f_u*f_uu + 2*f_v*f_uv,
		    2*f_u*f_uv + 2*f_v*f_vv
		   );
  }
  
}
